## IO模型

1.  阻塞IO模型
    1.  传统IO模型,在**读写数据过程中会发生阻塞现象**
    2.  用户线程发出IO请求后,内核会去查看数据是否就绪,如果没有就绪就会等待数据就绪,在此期间用户线程处于阻塞状态,用户线程交出CPU
    3.  数据就绪后,内核将数据拷贝到用户线程,并返回结果给用户线程,用户线程才解除block状态
2.  非阻塞IO模型
    1.  用户线程发起read操作后不需要等待就可得到结果,如果结果是error,那么可以再次发起read操作
    2.  如果内核中的数据准备好了,并且收到了用户线程的请求,那么就将数据拷贝到用户线程并返回
    3.  **用户线程需要不断的轮询,一直占用CPU,会导致CPU占用率非常高**
3.  多路复用IO模型
    1.  **有一个线程轮询多个socket的状态,只有当socket真正有读写事件时,才真正调用实际的IO读写操作**
    2.  **减少资源占用,适合连接数比较多的情况**,只需要一个线程就可以管理多个socket,系统不需要新建/维护多余的进程或线程
    3.  **在非阻塞IO中,由用户线程轮询socket状态,多路复用IO中,由内核进行,效率比用户线程高**
    4.  **通过轮询检测是否有事件,并且对事件逐一进行响应,因此如果事件响应体比较大,会导致后续的事件迟迟得不到处理,并且会影响新的事件轮询**
4.  信号驱动IO模型
    1.  用户线程发起一个IO请求操作,会给对应的socket注册一个信号函数,然后用户线程继续执行,当内核数据就绪时会发送信号给用户线程,用户线程接收到信号之后,便在信号函数中调用IO读写操作来进行实际的IO请求操作
5.  **异步IO模型(需要操作系统底层支持)**
    1.  只需要先发起一个请求,当接收内核返回的成功信号时表示IO操作已经完成,可以直接去使用数据了
    2.  在异步IO模型中,IO操作的两个阶段都不会阻塞用户线程
    3.  在信号驱动模型中,用户线程接收到信号表示数据已经就绪,需要用户线程调用IO函数进行实际的读写操作,在异步IO模型中,收到信号表示IO操作已经完成

