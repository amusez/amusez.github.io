## GC垃圾收集器

1.  **不可能三角:**
    1.  **内存占用**
    2.  **吞吐量**
    3.  **延迟**
2.  **空间分配担保:取之前每一次回收晋升到老年代对象容量的平均大小作为经验值,与老年代的剩余空间进行比较,决定是否进行full GC**
3.  Serial垃圾收集器(单线程,复制算法)
    1.  进行垃圾收集的时候,必须暂停其他所有的工作线程
4.  ParNew垃圾收集器(Serial+多线程)
    1.  使用多线程进行垃圾收集
    2.  除了Serial收集器之外,只有它能和CMS收集器配合工作
5.  Parallel Scavenge 收集器(多线程复制算法,比较高效)
    1.  **可控制吞吐量**
6.  Serial Old 收集器(单线程标记整理算法)
7.  Parallel Old 收集器(多线程标记整理算法)
8.  CMS收集器(**多线程标记清除算法**)
    1.  **主要目标是获取最短垃圾回收停顿时间**
    2.  工作过程
        1.  初始标记(STW)
        2.  并发标记
        3.  重新标记(STW)
        4.  并发清除
9.  G1收集器(region)
    1.  标记整理算法,不产生内存碎片
    2.  可以非常精确控制停顿时间,在不牺牲吞吐量前提下,实现低停顿垃圾回收
    3.  **G1收集器避免全区域垃圾收集,把堆内存划分为大小固定的几个独立区域**,并且跟踪这些区域的垃圾回收进度,同时在后台维护一个优先级列表,每次根据所允许的收集时间,**优先回收垃圾最多的区域**.区域划分和优先级区域回收机制,确保G1收集器可以在有效时间获得最高的垃圾收集效率
    4.  工作过程
        1.  初始标记(STW)
        2.  并发标记
        3.  最终标记(STW)
        4.  筛选回收(STW)
            1.  负责更新Region的统计数据,对各个Region的回收价值和成本进行排序
            2.  根据用户所期望的停顿时间来制定回收计划
10.  Shenandoah收集器(region)
     1.  openjdk中才有
     2.  使用转发指针和读屏障实现并发整理
11.  ZGC(region)
     1.  使用读屏障,染色指针和内存多种映射等技术来实现可并发的标记-整理算法
     2.  由于使用了染色指针,将一部分标志位存放在指针中,导致ZGC能够管理的内存不能超过4TB,不能支持32位平台,不能支持压缩指针
12.  Epsilon收集器(不收集)