## JVM如何确定垃圾

1.  引用计数算法
    1.  在对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加一,当引用失效时,计数器值就减一
    2.  在java中,引用和对象是有关联的.如果要操作对象则必须用引用.因为可以通过引用计数来判断对象是否可以被回收,即一个对象如果没有任何与之关联的引用,也即她们的引用计数为0则说明对象不太可能再被用到,那么这个对象就是可回收对象
    3.  **主流的java虚拟机并没有选用计数算法来管理内存**
    4.  引用计数算法虽然占用了一些额外的内存空间来进行计数,但是原理简单,判断效率也很高
    5.  引用计数算法有很多例外情况,必须要配合大量额外处理才能保证正确的工作,比如**对象之间循环引用问题**
        1.  **可使用弱引用解决,若 A 强引用了 B，那 B 引用 A 时就需使用弱引用，当判断是否为无用对象时仅考虑强引用计数是否为 0，不关心弱引用计数的数量**
        2.  通过**Recycler 算法**解决,但是在多线程环境下,引用计数变更也要进行昂贵的同步操作,性能较低
2.  可达性分析算法,又称引用链法
    1.  通过一系列称为"GC Roots"的根对象作为起始节点集,从这些节点开始,根据引用关系想下搜索,搜索过程所走过的路径称为"引用链"(Reference Chain),如果某个对象到GC Roots间没有任何因引用链相连,或者用图论的话来说就是从GC Roots到这个对象不可达时,则证明此对象是不可能再被使用的
    2.  可达性分析算法可更好的解决对象之间循环引用问题
    3.  **不可达对象不等价于可回收对象,不可待对象变为可回收对象至少要经过两次标记过程.两次标记后仍然是可回收对象,则将面临回收**
        1.  如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那ta将会被第一次标记,随后进行一次筛选,**筛选的条件是此对象是否有必要执行finalize()方法.假如对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,那么虚拟机将这两种情况都视为"没有必要执行"**
        2.  如果对象被判定为有必要执行finalize()方法,那么该对象将会被放置在叫F-Queue的队列中,稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法
            1.  执行是指虚拟机会触发这个方法开始运行,但并不承诺一定会等待它运行结束.这样做的原因是如果某个对象的finalize()方法执行缓慢,或者发生了死循环,将可能导致F-Queue队列中的其他对象永久处于等待甚至导致整个内存回收子系统的崩溃
        3.  收集器将对F-Queue中的对象进行第二次小规模的标记,对象只要重新与引用链上的任何一个对象建立关联,在第二次标记时它将被移出"即将回收"的集合
    4.  固定可作为GC Roots的对象可包括以下几种:
        1.  在虚拟机栈(栈帧中的本地变量表)中引用的对象,比如各个线程被调用的方法堆栈中使用到的参数/局部变量/临时变量等
        2.  在方法区中类静态属性引用的对象,比如java类的引用类型静态变量
        3.  在方法区中常量引用的对象,比如字符串常量池(String Table)里的引用
        4.  在本地方法栈中JNI(Native方法)引用的对象
        5.  java虚拟机内部的引用,如基本数据类型对应的Class对象,系统类加载器,一些常驻的异常对象(NullPointException/OutOfMemoryError)等
        6.  所有被同步锁(synchronized)持有的对象
        7.  反映java虚拟机内部情况的JMXBean/JVMTI中注册的回调/本地代码缓存等
    5.  除了固定的GC Roots集合外,根据用户所选用的垃圾收集器以及当前回收的内存区域不同,还可以有其他对象临时性的加入
        1.  **在分代收集和局部回收时,某个区域中的对象可能被位于堆中其他区域的对象所引用,需要将这些关联区域的对象也一并加入到GC Roots中**

