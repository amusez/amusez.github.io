## JVM运行时内存

1. java堆从GC的角度可以分为:新生代(Eden/From Survivor/To Survivor) 和老年代
   1. 新生代用来存放新生的对象,一般占据堆的1/3空间,由于频繁创建对象,新生代会频繁触发MinorGC进行垃圾回收
      1. Eden
         1. java的新生对象(**如果创建的对象占用内存很大,则直接分配到老年代**).内存不够时触发MinorGC
      2. ServivorFrom
         1. 上一次GC的幸存者,作为这一次GC的被扫描者
      3. ServivorTo
         1. 保留了一次MinorGC过程中的幸存者
      4. MinorGC的过程(复制-清空-互换)
         1. **minorGC采用复制算法**
            1. eden与ServivorFrom中存活的对象复制到ServivorTo(如果有对象的年龄已经达到了老年代的标准,则复制到老年代区),同时把这些对象的年龄+1(如果ServivorTo位置不够就放到老年区),达到最大年龄15就进入老年区(因为 JVM 中使用 4 个比特来表示对象的年龄)
            2. 清空eden和ServivorFrom中的对象
            3. ServivorTo和ServivorFrom互换,原来的ServivorTo成为下一次GC时的ServivorFrom
   2. 老年代主要存放应用程序中生命周期长的内存对象,老年代的对象比较稳定,MajorGC不会频繁执行.在进行MajorGC前一般都先进行了一次MinorGC,使得有新生代的对象到了老年代,导致空间不够用时才触发.当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC
      1. **MajorGC采用标记清除算法**
         1. 扫描一次所有老年代,标记出存活的对象,然后回收没有存活的对象
         2. 因为要扫描再回收,MajorGC的耗时比较长
         3. MajorGC会产生内存碎片,为了减少内存损耗,一般需要进行合并或者标记出来方便下次直接分配
         4. 当老年代也满了装不下的时候,就会抛出OOM异常
   3. 永久代只指内存的永久保存区域,主要存放Class和Meta的信息,Class在被加载的时候放入永久区域,它和存放实例的区域不同,**GC不会在主程序运行期对永久区域进行清理**.这也导致了永久代的区域会随着加载的Class的增多而最终抛出OOM异常
      1. 在 Java8 中,永久代已经被移除,被一个称为“元数据区”（元空间）的区域所取代.元空间 的本质和永久代类似,元空间与永久代之间最大的区别在于:元空间并不在虚拟机中,而是使用本地内存.因此默认情况下,元空间的大小仅受本地内存限制.类的元数据放入 native memory,字符串池和类的静态变量放入 java堆中,这样可以加载多少类的元数据就不再由 MaxPermSize 控制.而由系统的实际可用空间来控制

