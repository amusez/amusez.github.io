## redis缓存血崩/缓存穿透/缓存击穿

1.  缓存穿透
    1.  查询一个必然不存在的数据,比如user表,查询一个不存在的id,每次都会访问DB,如果有人恶意破坏,很可能直接对DB造成影响
    2.  解决办法: 如果一个查询返回的数据为空,仍然把这个空结果进行缓存,但它的过期时间会很短,最长不超过5分钟
    3.  BloomFilter(布隆过滤器)
2.  缓存雪崩
    1.  如果缓存集中在一段时间内失效,DB的压力凸显
    2.  解决办法(分析用户行为,尽量让失效时间点均匀分布)
        1.  在缓存失效后,通过加锁或者队列来控制读数据库写缓存的线程数量,比如某个key只允许一个线程查询和写缓存,其他线程等待
        2.  可以通过缓存reload机智,预先去更新缓存,在即将发生大并发访问前手动触发加载缓存
        3.  不同的key,设置不同的过期时间,让缓存失效的时间尽量均匀
        4.  做二级缓存或者双缓存策略.A1为原始缓存,A2为拷贝缓存,A1失效时,可以访问A2,A1缓存失效时间短,A2设置为长期
        5.  失效后sleep(rand())这样不会所有请求都去立刻请求DB
3.  缓存击穿(热点缓存重建)
    1.  对于一些设置了过期时间的key,如果这些key可能在某些时间点被超高并发的访问,是一种非常热点的数据
    2.  缓存击穿与缓存雪崩的区别在于击穿针对某一key缓存,雪崩则是很多key
    3.  解决方式
        1.  使用互斥锁
            1.  mutex,在缓存失效的时候,不是立即去load DB,而是先使用缓存工具的某些带成功操作返回值的操作(SETNX)去set一个mutex key,当操作返回成功时,再进行load DB的操作并回设缓存,否则就重试整个get缓存的方法
            2.  只允许一个线程重建缓存,其他线程等待重建缓存的线程执行完,重新从缓存获取数据即可
        2.  永远不过期
            1.  物理不过期: 不设置过期时间
            2.  为每个value设置一个逻辑过期时间,当发现超过逻辑过期时间后,使用单独的线程去构建缓存